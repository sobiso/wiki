---
title: Private Transactions
---
_The development of this feature was supported by the Energy Web Foundation in order to expedite the energy sector revolution towards decentralisation._

## Solution's Description

### Introduced terminology
**Public contract**: A specifically crafted smart contract deployed on Ethereum blockchain that wraps a private contract. See the [source of the contract](https://github.com/parity-contracts/private-tx/blob/master/contracts/PrivateContract.sol). The public contract stores the encrypted code and state variables of the private contract. The deployment transaction for the public contract has to be generated by the Parity Ethereum client.

**Private contract**: A smart contract stored encrypted inside a public contract. The state and code of a private contract is not publicly readable. Reading or modifying a private contract's state and code is only possible for the specific accounts, these accounts are specified during the public contract's deployment.

**Validator**: An account that can allow a private contract's state change. The list of validators is specified during the public contract's deployment. Any account can be set as a validator. There is no blockchain incentive defined for the validator account.

**Private transaction**: A specifically crafted message containing encrypted data and a modified private contract's state. It requires the signature of all the validators in order for the changes to be applied.

**Public transaction**: A regular transaction call to a public contract that results in changes being stored in a private contract.

### Overall system architecture
This private transactions system implements a solution allowing to store, modify and view encrypted data (state) using the Ethereum blockchain. The solution doesn't depend on the type of the chain and can be deployed on any Ethereum based chain with any consensus algorithm (public transactions must be mined in order to be included into the blockchain but it's up to the chain, how to achieve mining).
The system contains the following major components:
- Parity nodes. The system uses specifically crafted messages with encrypted data in order to communicate between nodes.
- A public contract containing the encrypted code of a private contract (see terminology above).
- Secret Store nodes used to create and provide access to the encryption key. One key is associated with one public contract. This key is used to encrypt the state of the private contract and any message exchanged between the nodes (to gather validator's signatures for instance). The exact Secret Store URL is specified for every Parity node participating in a private transaction system (see [Parity-flags](#parity-flags) for more details). A permissioning contract deployed and specified on the chain's registry may be used to describes which nodes have access to which contract's key. The availability of the Secret Store is crucial for the system to work flawlessly.

In the below example: Nodes A and C have access to the contract's key. Node B doesn't. Node C is specified as a validator for the system.

![private-transactions-solution](images/private-transactions-solution.png)

### Flow description
We use a trivial private contract as example:
`contract Test1 { 
   bytes32 public x; 
   function setX(bytes32 _x) {
      x = _x; 
    }
}`
In order to call `setX` method of the deployed private contract, the user needs to:

1) Compose a regular transaction calling the contract's corresponding methods, in this example `SetX(42)`:

```bash
curl --data '{"method":"parity_composeTransaction","params":[{"from":"0xcf9e2287227c5cc5978e7bdbbdaf293fe4992a24","to":"0x52f5f1b8c785ab1c0e892b4c46b080fde9ad992b","data":"0xbc64b76d2a00000000000000000000000000000000000000000000000000000000000000"}],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8549
```

Where `0xbc64b76d2a...00000000` corresponds to the call of `SetX()` using an arbitrary parameter `42`.

2) Sign the transaction.
3) Send the signed transaction using `private_sendTransaction` API method:

```bash
curl --data '{"method":"private_sendTransaction","params":["0xf88407...1137"],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8549
```

Where `0xf88407...1137` is the signed transaction created previously.

The next steps of the flow are shown in the picture below:

![private-transactions-flow](images/private-transactions-flow.png)

### Public/private contracts internals
Let's consider another example in order to understand in details the wrapping of a private contract into a public one. If we want to use the following voting contract as the private contract: [source](http://solidity.readthedocs.io/en/v0.4.21/solidity-by-example.html#voting). The public contract wrapping the aforementioned private contract must be deployed using `private_composeDeploymentTransaction` [API method](#rpc-api). As explained before, this API call will prepare a transaction that once broadcasted will deploy a public contract storing the private contract's state and code (the deployed public contract's [looks like this](https://github.com/parity-contracts/private-tx/blob/master/contracts/PrivateContract.sol)).

To call `vote(1)` from the private contract for instance, the system performs the following steps:

![private-transactions-wrapping](images/private-transactions-wrapping.png)

### Current limitations:
- Only one private transaction per block per contract is allowed (since pending state is not implemented for private transactions yet).
- The current implementation requires all validators to verify any private transaction. This is not configurable yet.

## Setup of the private network
The following steps need to be performed in order to setup a blockchain with private transactions using Parity client:

0) (Pre-requisite) Contracts registry must be deployed on the chain.
1) Deploy the Secret Store permissioning contract and add its address to the contracts registry under the name **secretstore_acl_checker**.
A trivial example of the permissioning contract can be found [here](https://gist.github.com/grbIzl/14541e57f50b3ceae9831512c8234624)
The only requirement for such a contract is to have the ABI:

`function checkPermissions(address user, bytes32 document) constant returns (bool) {} `

It's up to the network's administrator to define the logic for providing access to the keys inside this contract.

2) Deploy the private contract.
In the following example the same trivial private contract is used:
`contract Test1 { 
   bytes32 public x; 
   function setX(bytes32 _x) {
      x = _x; 
    }
}`
In order to deploy the private contract:

2.1) Composed and sign a regular transaction with the private contract's code
Example:
```bash
curl --data '{"method":"parity_composeTransaction","params":[{"from":"0xcf9e2287227c5cc5978e7bdbbdaf293fe4992a24","data":"0x6060604052341561000f57600080fd5b60d88061001d6000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680630c55699c146046578063bc64b76d14607457600080fd5b3415605057600080fd5b60566098565b60405180826000191660001916815260200191505060405180910390f35b3415607e57600080fd5b6096600480803560001916906020019091905050609e565b005b60005481565b8060008160001916905550505600a165627a7a723058206acbdf4b15ca4c2d43e1b1879b830451a34f1e9d02ff1f2f394d8d857e79d2080029"}],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8549
```

Where `0x606060405234...9d2080029` is the private contract's code.
The resulting transaction must then be signed.

2.2) Generate the transaction for the specifically crafted public contract using the private API.
Example:
```bash
curl --data '{"method":"private_composeDeploymentTransaction","params":["pending", "0xf9014203...ba4a30127e29774d15b1e12be", ["0x7ffbe3512782069be388f41be4d8eb350672d3a5"], "0x0"],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8549`
```

Where `0xf9014203...ba4a30127e29774d15b1e12be` is the signed transaction from the previous step.
This method returns a transaction, which should be signed as well. See [API section below](#rpc-api) for more details.


2.3) The transaction containing the specifically crafted public contract should be broadcasted using `eth_sendRawTransaction` method, resulting in the public contract being deployed on the blockchain.

3) Specify the private contract key permissions:
In order to obtain the key id associated with the contract, use the `private_contract_key` private API method (that can be called locally).
Example:
```bash
curl --data '{"method":"private_contract_key","params":["0x52f5f1b8c785ab1c0e892b4c46b080fde9ad992b"],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8549
```

Where `0x52f5f1b...d992b` is the public contract's address returned at step 2.2 ([see API description](#rpc-api) for more details).
The permissions for this key id now need to get set in the Secret Store permissioning contract.
You can do so by calling the method `addKey(address[] users, bytes32 key)` from the [the sample contract](https://gist.github.com/grbIzl/14541e57f50b3ceae9831512c8234624) with key id and the address list of the nodes allowed to use the key.

## Parity flags
To use private transactions functionality, Parity client must be launched with the following flags:

- `--private-tx-enabled`.
Enables private transactions processing for the node. Not set by default.

- `--private-signer=[ACCOUNT]`.
Account address used to sign the public transactions containing validated private contract state change (corresponding to the last arrow in above diagram).

- `--private-validators=[ACCOUNTS]`.
Comma-delimited list of addresses allowed to validate private transactions.

- `--private-account=[ACCOUNT]`.
Account used for signing the Secret Store requests. This account should have access to the contract's key. It must be specified during private transactions system setup in the permissioning contract. All nodes (senders and validators) participating in private transactions system must have this account setup in order to encrypt/decrypt the data.

- `--private-sstore-url=[URL]`.
Secret Store URL used to request and create encryption keys.

- `--private-sstore-threshold=[NUM]`.
Optional - Specifies the Secret Store threshold number of nodes in the cluster used to store the key (more info in the [Secret Store documentation](https://paritytech.github.io/wiki/Secret-Store) for details). Default 0.

- `--private-passwords=[FILE]...`
Path to the file containing the passwords to unlock any account specified above (signer, private account, validators)

Example of a parity call containing these flags:

```bash
~/parity/parity --config "/chain/config.toml" --author "0x7ffbe3512782069be388f41be4d8eb350672d3a5" --engine-signer "0x7ffbe3512782069be388f41be4d8eb350672d3a5" --private-tx-enabled --private-validators "0x7ffbe3512782069be388f41be4d8eb350672d3a5" --private-account "0x7ffbe3512782069be388f41be4d8eb350672d3a5" --private-sstore-url "http://secretstore:8082" --private-passwords "/parity/password.txt"
```

## RPC API
Several RPC methods were added in order to access private transactions functionality. You must enable `private` api  in your node's configuration/flags:

`[rpc]`
`apis = ["web3", "eth", "net", "personal", "parity", "parity_set", "traces", "rpc", "parity_accounts", "private"]`
or
`--jsonrpc-apis private`

Methods:

### `private_composeDeploymentTransaction`

Returns a specifically crafted transaction wrapping the private contract inside the public contract. The transaction is then expected to be signed and broadcasted to the network.
#### Parameters
`num: BlockNumber`: Integer - block number, or the string `'latest'`, `'earliest'` or `'pending'`
`request`: Bytes - signed regular transaction for contract's creation (in hex)
`validators`: Vec<H160> - list of validator accounts for this contract
`gas_price`: U256 - gas price for the transaction

#### Returning data:
`struct PrivateTransactionReceiptAndTransaction {`
`/// Receipt`
`receipt: PrivateTransactionReceipt,`
`/// Transaction`
`transaction: TransactionRequest,`
`}`

`struct PrivateTransactionReceipt {`
`/// Transaction Hash`
`transaction_hash: H256,`
`/// Private contract address`
`contract_address: Option<H160>,`
`/// Status code`
`status_code: u8,`
`}`

### `private_sendTransaction`
Sends a private transaction (see Private Transactions flow for implementation details).
#### Parameters
`request`: Bytes - signed regular transaction (in hex).

### `private_call`
View encrypted data of the private contract. The resulted call will be made internally.
#### Parameters
`from`: 20 Bytes - Address of the account used to read the private contract's state
`to`: 20 Bytes - Address of the public contract wrapping the private contract
`num`: Integer - block number, or the string `'latest'`, `'earliest'`.
`request`: CallRequest - call parameters in the form of regular transaction. For example: 

```bash
curl --data '{"method":"private_call","params":["latest",{"from":"0xcf9e2287227c5cc5978e7bdbbdaf293fe4992a24","to":"0xcd96d189596c690ff983e4e14d1838d0305186dc","data":"0x0c55699c","nonce":"0x0"}],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8549
```
The data field `0x0c55699c` corresponds to `getX()` method of the previously used trivial private contract. This call happens off-chain and no transaction gets broadcasted. It allows a user to read the state of a private contract, given that the account in from field has the key to decrypt the private contract's state.

### `private_contract_key`
Returns key id associated with the deployed public contract.
#### Parameters
`contract_address`: H160 - address of the private contract
